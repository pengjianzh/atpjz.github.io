[{"title":"Nginx搭建手册","date":"2021-09-12T15:57:46.000Z","url":"/post/bfa40fac.html","tags":[["Nginx","/tags/Nginx/"]],"categories":[["安装教程","/categories/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"]],"content":"Nginx安装配置手册所需依赖：gcc、g++、patch、ssl、pcre、zlib 检查是否已安装gcc：gcc -v 查看是否安装gcc-c++：g++ -v 查看是否安装patch命令： patch -v 查看make命令是否安装：make -v 如果提示没有安装，根据服务器操作系统自行安装 下载nginx及所需依赖包下载nginx进入下载页，选择稳定版，这里演示下载的是1.20.1 下载openssl进入下载页，页面往下拉选择openssl-1-1-1l这个版本 下载pcre点击这里进入下载页，也可以点击这里直接下载pcre-8.45版本，这里用这个版本演示 下载zlib点击这里进入下载页，也可以点击这里直接下载zlib-1.2.11，这里用这个版本演示 下载nginx插件点击这里下载nginx心跳检测插件 点击这里下载sticky插件 上传到服务器这里放到/home/pengjianzhong/下载/nginx目录下载并全部解压 开始安装现在所需包就下载完成了，下面开始安装 安装pcre 安装zlib 安装openssl 编译安装nginx 启动nginx 浏览器访问显示Welcome to nginx!则启动成功，访问不了先检查下是不是端口没开放 安装nginx_upstream_check_module模块 添加sticky，stub_status，gzip重新编译启动 可能会报错 修改sticky包下的ngx_http_sticky_misc.c文件 再次编译，就能通过了 安装完成后进入安装目录 启动试下 修改配置附件里提供了一个默认配置 修改http下的upstream和http下server中的location 修改worker_processes 和worker_cpu_affinity 修改worker_rlimit_nofile 为 ulimit -n 的值 其他的基本不用修改 配置说明看下面 访问 查看服务状态 安装包下载"},{"title":"Java集合分享","date":"2021-09-12T15:57:00.000Z","url":"/post/d25a5ce4.html","tags":[["集合","/tags/%E9%9B%86%E5%90%88/"],["Java","/tags/Java/"]],"categories":[["Java","/categories/Java/"]],"content":"集合继承体系 List平时都用到那哪些方式遍历一个list？ 每种方式之前有什么区别吗？ ArrayList先来看几个问题 ArrayList的数据结构 构造方法有哪些，区别是什么 默认初始化大小是多少 什么时候扩容，扩容时做了什么 构造方法 扩容 这三种创建list方式，分别要执行多少次扩容方法？ fail-fast AbstractList： fail-safe采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 ArrayList使用fail-fast机制自然的英明因为它增强了数据的安全性但在某些场景，我们可能想避免。fail-fast机制产生的错误，我们这时就要将ArrayList替换为使用故障安全机制的CopyOnWriteArrayList。 一些问题及可能会踩的坑ArrayList和LinkedList的选取 Collections.emptyList()与直接new一个实例的区别 add(int index, E element) 向指定位置写入数据 Arrays.asList返回的 ArrayList 并非 “ArrayList” Collections#unmodifiableList 粗糙的不可变集合 Map键值对结构key–&gt;value 我们平时使用map来做啥？ HashMap还是先来看几个问题 HashMap的数据结构 构造方法有哪些，区别是什么 默认初始化大小是多少 什么时候扩容，扩容时做了什么 构造函数 内部使用一个Node数组存放数据 数组的每个元素是一个Node对象 默认初始容量为 16，默认负载因子为 0.75 threshold = 数组长度 * loadFactor，当元素个数超过threshold(容量阈值)时，HashMap 会进行扩容操作 这里需要注意的一点是 table 数组并不是在构造方法里面初始化的，它是在 resize(扩容)方法里进行初始化的。 table 数组长度永远为 2 的幂次方 HashMap 是通过一个名为 tableSizeFor 的方法来确保 HashMap 数组长度永远为2的幂次方的 put 判断Node数组table是否为空或为null，为空或为null执行resize()进行扩容； 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，\b转向③； 判断table[i]的首个元素是否key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals； 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5； 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 扩容机制指定位置插入元素 判断插入元素后的size是否大于阈值 大于则扩容 resize guava扩展集合com.google.common.collect guava对jdk集合类的扩展，包括不可变集合，新集合类型:，集合工具类: 提供java.util.Collections中没有的集合工具，扩展工具类：让实现和扩展集合类变得更容易，比如创建Collection的装饰器，或实现迭代器。 Multiset 可以看到他的实际存储结构为一个Map，key为存储元素，Count类型存储是key这个元素的个数 HashMultiset是最常用的，其实现是以Map&lt;T,Count&gt;为存储结构，其中的add和remove方法是对Count进行的操作（Count并不是线程安全的），Multiset与Map&lt;T,Integer&gt;最大的不同是，Multiset遍历时可以遍历出Map.keySize * count个元素，而map却不可以 关于Multiset和Map的显著区别还包括： Multiset中的元素计数只能是正数。 multiset.size()返回集合的大小，等同于所有元素计数的总和。对于不重复元素的个数，应使用elementSet().size()方法。（因此，add(E)把multiset.size()增加1） multiset.iterator()会迭代重复元素，因此迭代长度等于multiset.size()。 Multiset支持直接增加、减少或设置元素的计数。setCount(elem, 0)等同于移除所有elem。 对multiset 中没有的元素，multiset.count(elem)始终返回0。 Multimap大家一定写过Map&lt;K, List&gt;或Map&lt;K, Set&gt;这样的结构，Guava的 Multimap可以很容易地把一个键映射到多个值。 Multimap底层是一个Map&lt;K, Collection&gt;结构，并且有一个totalSize记录总的键值对数量 Multimap.get(key)总是返回非null、但是可能空的集合。 如果你更喜欢像Map那样，为Multimap中没有的键返回null，请使用asMap()视图获取一个Map&lt;K, Collection&gt;。（或者用静态方法Multimaps.asMap()为ListMultimap返回一个Map&lt;K, List&gt;） 当且仅当有值映射到键时，Multimap.containsKey(key)才会返回true。尤其需要注意的是，如果键k之前映射过一个或多个值，但它们都被移除后，Multimap.containsKey(key)会返回false。 Multimap.entries()返回Multimap中所有”键-单个值映射”——包括重复键。如果你想要得到所有”键-值集合映射”，请使用asMap().entrySet()。 Multimap.size()返回所有”键-单个值映射”的个数，而非不同键的个数。要得到不同键的个数，请改用Multimap.keySet().size()。 BiMap传统上，实现键值对的双向映射需要维护两个单独的map，并保持它们间的同步。但这种方式很容易出错，而且对于值已经在map中的情况，会变得非常混乱。BiMap&lt;K, V&gt;是特殊的Map：可以用 inverse()反转BiMap&lt;K, V&gt;的键值映射保证值是唯一的，因此 values()返回Set而不是普通的Collection 向BiMap中添加两个相同的value会抛异常 添加功能有两种，一个是put方法，一个是forcePut方法： "},{"title":"arthas-and-javaagent","date":"2021-09-12T03:35:11.000Z","url":"/post/d57220e9.html","tags":[["arthas","/tags/arthas/"],["javaagent","/tags/javaagent/"],["系统检测","/tags/%E7%B3%BB%E7%BB%9F%E6%A3%80%E6%B5%8B/"],["问题排查","/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"]],"categories":[["Java","/categories/Java/"]],"content":"ArthasArthas（阿尔萨斯） 是基于 Greys 进行二次开发的全新在线诊断工具，利用Java6的Instrumentation特性，动态增强你所指定的类，获取你想要到的信息, 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，让你轻松定位、分析诊断问题 Arthas 能为你做什么？ 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ Arthas的安装以及使用下载安装 命令列表 常用命令logger查看logger信息，更新logger level 使用参考 代码中打印日志写的logger.debug，现场日志配置的error，怎么办 logger -n 查看 某个类或某个包的日志级别 logger -n [类名/包名] –level [日志级别] jad反编译指定已加载类的源码 使用参考 mcMemory Compiler/内存编译器，编译.java文件生成.class 使用参考 在 Arthas Console 上，反编译出来的源码是带语法高亮的，阅读更方便 当然，反编译出来的 java 代码可能会存在语法错误，但不影响你进行阅读理解 redefine加载外部的.class文件，redefine jvm已加载的类。 使用参考 redefine的class不能修改、添加、删除类的field和method，包括方法参数、方法名称及返回值 如果mc失败，可以在本地开发环境编译好class文件，上传到目标系统，使用redefine热加载class 目前redefine 和watch/trace/jad/tt等命令冲突，以后重新实现redefine功能会解决此问题 注意， redefine后的原来的类不能恢复，redefine有可能失败（比如增加了新的field），参考jdk本身的文档。 reset命令对redefine的类无效。如果想重置，需要redefine原始的字节码。 redefine命令和jad/watch/trace/monitor/tt等命令会冲突。执行完redefine之后，如果再执行上面提到的命令，则会把redefine的字节码重置。 原因是jdk本身redefine和Retransform是不同的机制，同时使用两种机制来更新字节码，只有最后修改的会生效。 热更新 背景：项目部署到现场之后发现出现了一个BUG，查看日志发现日志内发现抛出了一个空指针，本地不能复现。 before：远程到生产环境，或者驻地操作，将现场环境的报错的class发回，用反编译软件打开，看下代码是否和本地研发环境一致。然后再出错的地方加日志然后发替换文件给驻地替换重启，操作之后发回日志，定位问题然后修改。缺点：耗时太长并且生产环境不能随便重启，万一驻地不配合或者有事外出那就阻断在了这里，而且辛辛苦苦哪个替换文件只是加个日志太浪费资源了，并且在后期docker化之后，出替换文件很困难，驻地不一定会配合了。 after：丢一个Arthas到生成环境上（或者可以将Arthas安装到你的镜像里或者在docker上启动，就可以在docker容器里利用Arthas来排查问题），然后启动Arthas，利用Arthas的watch命令查看函数的返回值，如果需要添加日志或者修改代码测试，可以利用Arthas的热更新，来不重启立即更新代码检测，立马就可以定位问题，如果的确是代码问题就走流程解决。比起之前的方法的优点就是可以很快的定位问题不用重启系统也可以解决，缺点是如果不慎重用热更新会被同事追杀的。 如果本地有源码且和生产环境一致，可直接在本地修改java文件，编译为class后放到服务器上，直接到步骤5 watch方法执行数据观测 让你能方便的观察到指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 \bOGNL 表达式进行对应变量的查看。 使用参考 target ：类属性 params ：方法入参 returnObj：方法返回值 -x 遍历深度 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 express 观察表达式 condition-express 条件表达式 [b] 在方法调用之前观察 [e] 在方法异常之后观察 [s] 在方法返回之后观察 [f] 在方法结束之后(正常返回和异常返回)观察 [E] 开启正则表达式匹配，默认为通配符匹配 [x:] 指定输出结果的属性遍历深度，默认为 1 trace方法内部调用路径，并输出方法路径上的每个节点上耗时 ognl执行ognl表达式 使用参考 一般项目中总能找到静态获取ApplicationContext的方法，通过这个方法获取到ApplicationContext，然后几乎可以执行所有context中bean 的方法 其他用法自行学习ognl表达式 options全局开关 使用参考 名称 默认值 描述 unsafe false 是否支持对系统级别的类进行增强，打开该开关可能导致把JVM搞挂，请慎重选择！ dump false 是否支持被增强了的类dump到外部文件中，如果打开开关，class文件会被dump到/$&#123;application working dir&#125;/arthas-class-dump/目录下，具体位置详见控制台输出 batch-re-transform true 是否支持批量对匹配到的类执行retransform操作 json-format false 是否支持json化的输出 disable-sub-class false 是否禁用子类匹配，默认在匹配目标类的时候会默认匹配到其子类，如果想精确匹配，可以关闭此开关 support-default-method true 是否支持匹配到default method，\b默认会查找interface，匹配里面的default method。参考 #1105 save-result false 是否打开执行结果存日志功能，打开之后所有命令的运行结果都将保存到~/logs/arthas-cache/result.log中 job-timeout 1d 异步后台任务的默认超时时间，超过这个时间，任务自动停止；\b比如设置 1d, 2h, 3m, 25s，分别代表天、小时、分、秒 print-parent-fields true 是否打印在parent class里的filed 保存运行结果 shutdown如果只是退出当前的连接，可以用quit或者exit命令。Attach到目标进程上的arthas还会继续运行，端口会保持开放，下次连接时可以直接连接上。 如果想完全退出arthas，可以执行shutdown命令。 IDEA插件使用文档 更多Arthas操作看官方文档 Javaagent以下内容复制于官方文档中的readme 概述javaagent是一个简单优雅的java agent,利用java自带的instrument特性+javassist字节码编辑技术，实现了无侵入的方法级性能监控。相比于NewRelic或者开源的pinpoint,以及阿里的arthas,本工具主打的是简单，我们只记录每个方法的执行次数和时间，并输出到json格式的日志文件中。基于javaagent的日志，你可以使用严丽同学开发的agent日志分析工具进行分析查询，也可以使用在线日志分析器，或者可以自己去写分析器，这样可以让你快速定位生产环境的性能瓶颈。 集成java启动参数中就有javaagent,你只需要在JAVA_OPTS中加入-javaagent:/opt/javaagent/javaagent.jar=/opt/javaagent/agent.properties就实现了方法级监控。其中=前指定的是jar包的路径，=后指定的是对agent的一些配置参数。 agent.properties说明 agent日志分析器使用agent日志分析器是我同事严丽使用SpringBoot+h2数据库开发的分析工具，除了基础功能，对于有sql能力的同学，你可以直接使用console登录后，直接写sql进行统计，你可以按自己想要的维度来进行处理。 JDBC URL: jdbc:h2:mem:~/h2test USer Name : sa Password : 空 登录后，你就可以尽情的写sql了。 例： 增加启动参数 -javaagent:D:/javaagent/javaagent-2.1.0.jar=D:/javaagent/agent.properties 然后等着看日志 日志记录一个周期内监控的包下，方法调用次数和时间 "},{"title":"guava-collect","date":"2021-09-12T03:34:30.000Z","url":"/post/ba118fad.html","tags":[["集合","/tags/%E9%9B%86%E5%90%88/"],["Java","/tags/Java/"],["guava","/tags/guava/"]],"categories":[["Java","/categories/Java/"]],"content":"guava-collect分享Guava是一种基于开源的Java库，它包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。这些高质量的API可以使你的java代码更加优雅，更加简洁，让你的工作更加轻松愉悦，类似Apache Commons工具集 com.google.common.annotations：普通注解类型。com.google.common.base：基本工具类库和接口。com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类。com.google.common.eventbus：发布订阅风格的事件总线。com.google.common.hash： 哈希工具包。com.google.common.io：I/O工具包。com.google.common.math：原始算术类型和超大数的运算工具包。com.google.common.net：网络工具包。com.google.common.primitives：八种原始类型和无符号类型的静态工具包。com.google.common.reflect：反射工具包。com.google.common.util.concurrent：多线程工具包。 集合[Collections]com.google.common.collect guava对jdk集合类的扩展，包括不可变集合，新集合类型:，集合工具类: 提供java.util.Collections中没有的集合工具，扩展工具类：让实现和扩展集合类变得更容易，比如创建Collection的装饰器，或实现迭代器。 主要内容： 不可变集合 新集合类型 集合工具类 guava的不可变集合不可变对象有很多优点： Collections.unmodifiableXXX和ImmutableXXX在JDK中提供了Collections.unmodifiableXXX系列方法来实现不可变集合, 但是存在一些问题，下面我们先看一个具体实例： 不支持的操作 来看下ImmutableList 那么immutable集合是绝对不会改变吗 Collections.unmodifiableXXX返回的是原来容器的视图： 返回的容器无法修改 对原有容器进行修改，会影响返回容器的内容，没有做到真正的不可变：例如：通过Collections.unmodifiablelist(originList)得到一个不可变容器unmodifiableList，当修改originList时，unmodifiableList也会受到影响。 透过视图查看容器的内容 容器内容的变更也会通过视图展现出来 Collections.unmodifiableXXX系列方法源码：只是屏蔽了原来能改变集合的一些方法。 Guava提供的不可变容器 返回的不是原对象的视图，而是原容器的一份拷贝；调用add() / set() 方法是报出异常 因为只是copy了原容器本身（reference），并不是deep copy，因此，对容器中的元素内容的修改，也会影响ImmutableXXX 以ImmutableList为例，它内部维护了一个Object数组 内部对象的地址不再是原来List的地址，因此只是改变原来list的值，ImmutableList的值不会改变。但也仅仅是不能改变地址而已，如果改变改地址指向对象的值，集合内容还是会改变。 创建不可变集合不可变集合可以用如下多种方式创建: copyOf 方法 of 方法 Builder 工具 新集合类型 集合接口 属于JDK还是Guava 对应的Guava工具类 Collection JDK Collections2：不要和java.util.Collections混淆 List JDK Lists Set JDK Sets SortedSet JDK Sets Map JDK Maps SortedMap JDK Maps Queue JDK Queues Multiset Guava Multisets Multimap Guava Multimaps BiMap Guava Maps Table Guava Tables Multiset 元素可重复的setMultimap 一键多值的MapBiMap 键值对双向的MapTable 表格ClassToInstanceMapRangeSetRangeMap Multiset看一段代码，统计单词出现的次数 虽然没什么问题，但是看起来很繁琐。而且不支持统计多种信息，比如总元素数量。看看Multiset如何实现。 常用实现 Multiset 接口的类有： HashMultiset: 元素存放于 HashMap LinkedHashMultiset: 元素存放于 LinkedHashMap，即元素的排列顺序由第一次放入的顺序决定 TreeMultiset:元素被排序存放于TreeMap EnumMultiset: 元素必须是 enum 类型 ImmutableMultiset: 不可修改的 Mutiset Multiset不是一个Set，它没有继承Set接口，它继承的是Collection接口，你可以向Multiset中添加重复的元素，Multiset会对添加的元素做一个计数。Multiset接口定义的方法主要有： add(E element) :向其中添加单个元素 add(E element,int occurrences) : 向其中添加指定个数的元素 count(Object element) : 返回给定参数元素的个数 int remove(E element) : 移除一个元素，其count值会相应减少 remove(E element,int occurrences): 移除相应个数的元素 elementSet() : 将不同的元素放入一个Set中 entrySet(): 类似与Map.entrySet 返回Set&lt;Multiset.Entry&gt;。包含的Entry支持使用getElement()和getCount() setCount(E element ,int count): 设定某一个元素的重复次数 setCount(E element,int oldCount,int newCount): 将符合原有重复个数的元素修改为新的重复次数 retainAll(Collection c) : 保留出现在给定集合参数的所有的元素 removeAll(Collectionc) : 去除出现给给定集合参数的所有的元素 看下源码：Multiset的接口中方法的实现在AbstractMapBasedMultiset抽象类中 Multiset的接口中方法 HashMultiset是最常用的，其实现是以Map&lt;T,Count&gt;为存储结构，其中的add和remove方法是对Count进行的操作（Count并不是线程安全的），Multiset与Map&lt;T,Integer&gt;最大的不同是，Multiset遍历时可以遍历出Map.keySize * count个元素，而map却不可以，最大的区别就在于其itertator和Entry&lt;T,Count&gt;的iterator实现代码如下： 关于Multiset和Map的显著区别还包括： Multiset中的元素计数只能是正数。 multiset.size()返回集合的大小，等同于所有元素计数的总和。对于不重复元素的个数，应使用elementSet().size()方法。（因此，add(E)把multiset.size()增加1） multiset.iterator()会迭代重复元素，因此迭代长度等于multiset.size()。 Multiset支持直接增加、减少或设置元素的计数。setCount(elem, 0)等同于移除所有elem。 对multiset 中没有的元素，multiset.count(elem)始终返回0。 Multimap大家一定写过Map&lt;K, List&gt;或Map&lt;K, Set&gt;这样的结构，Guava的 Multimap可以很容易地把一个键映射到多个值。可以用两种方式思考Multimap的概念： ”键-单个值映射”的集合：a -&gt; 1 a -&gt; 2 a -&gt;4 b -&gt; 3 c -&gt; 5 ”键-值集合映射”的映射：a -&gt; [1, 2, 4] b -&gt; 3 c -&gt; 5一般来说，Multimap接口应该用第一种方式看待，但asMap()视图返回Map&lt;K, Collection&gt;，让你可以按另一种方式看待Multimap。重要的是，不会有任何键映射到空集合：一个键要么至少到一个值，要么根本就不在Multimap中。 修改MultimapMultimap.get(key)以集合形式返回键所对应的值视图，即使没有任何对应的值，也会返回空集合。ListMultimap.get(key)返回List，SetMultimap.get(key)返回Set。对值视图集合进行的修改最终都会反映到底层的Multimap。 修改Multimap的方法有： put(K, V) 添加键到单个值的映射 multimap.get(key).add(value) putAll(K, Iterable) 依次添加键到多个值的映射 Iterables.addAll(multimap.get(key), values) remove(K, V) 移除键到值的映射；如果有这样的键值并成功移除，返回true。 multimap.get(key).remove(value) removeAll(K) 清除键对应的所有值，返回的集合包含所有之前映射到K的值，但修改这个集合就不会影响Multimap了。 multimap.get(key).clear() replaceValues(K, Iterable) 清除键对应的所有值，并重新把key关联到Iterable中的每个元素。返回的集合包含所有之前映射到K的值。 multimap.get(key).clear(); Multimap.get(key)总是返回非null、但是可能空的集合。这并不意味着Multimap为相应的键花费内存创建了集合，而只是提供一个集合视图方便你为键增加映射值 如果有这样的键，返回的集合只是包装了Multimap中已有的集合；如果没有这样的键，返回的空集合也只是持有Multimap引用的栈对象，让你可以用来操作底层的Multimap。因此，返回的集合不会占据太多内存，数据实际上还是存放在Multimap中。 如果想Multimap中没有的键返回null，使用asMap()视图获取一个Map&lt;K, Collection&gt;。（或者用静态方法Multimaps.asMap()为ListMultimap返回一个Map&lt;K, List&gt;。对于SetMultimap和SortedSetMultimap，也有类似的静态方法存在） 当且仅当有值映射到键时，Multimap.containsKey(key)才会返回true。尤其需要注意的是，如果键k之前映射过一个或多个值，但它们都被移除后，Multimap.containsKey(key)会返回false。 Multimap.entries()返回Multimap中所有”键-单个值映射”——包括重复键。如果你想要得到所有”键-值集合映射”，请使用asMap().entrySet()。Multimap.size()返回所有”键-单个值映射”的个数，而非不同键的个数。要得到不同键的个数，请改用Multimap.keySet().size()。 实现 键行为类似 值行为类似 ArrayListMultimap HashMap ArrayList HashMultimap HashMap HashSet LinkedListMultimap LinkedHashMap LinkedList LinkedHashMultimap LinkedHashMap LinkedHashMap TreeMultimap TreeMap TreeSet ImmutableListMultimap ImmutableMap ImmutableList ImmutableSetMultimap ImmutableMap ImmutableSet HashMultimap 除了两个不可变形式的实现，其他所有实现都支持null键和null值 内部有totalSize记录元素总个数 get方法不会返回null BiMap传统上，实现键值对的双向映射需要维护两个单独的map，并保持它们间的同步。但这种方式很容易出错，而且对于值已经在map中的情况，会变得非常混乱。BiMap&lt;K, V&gt;是特殊的Map：可以用 inverse()反转BiMap&lt;K, V&gt;的键值映射保证值是唯一的，因此 values()返回Set而不是普通的Collection 向BiMap中添加两个相同的value会抛异常 下面看一下BiMap的 添加删除和插入方法 BiMap 注意！inverse方法返回一个反转后的BiMap，即key/value互相切换的映射。这个反转的map并不是一个新的map，而是一个视图，这意味着，你在这个反转后的map中的任何增删改操作都会影响原来的map 集合工具类Collection2filter（）：只保留集合中满足特定要求的元素 transform（）：类型转换 多个Function组合 这里的transform(function1,function2)是有顺序的，会先执行function2函数，再执行function1比如这里如果把f3和f4的位置交换，结果就变成：[NOE, ZUO, NOE, DIE, WHY, YOU, TRY, NOE, TRY, NOE, HIG, GIV, MEE, FIV] Iterables 迭代器工具集 Lists 列表工具集 Sets 集合工具集 Maps 集合工具集 Maps.uniqueIndex(Iterable,Function)通常针对的场景是：有一组对象，它们在某个属性上分别有独一无二的值，而我们希望能够按照这个属性值查找对象——译者注：这个方法返回一个Map，键为Function返回的属性值，值为Iterable中相应的元素，因此我们可以反复用这个Map进行查找操作。 比方说，我们有一堆字符串，这些字符串的长度都是独一无二的，而我们希望能够按照特定长度查找字符串： 作为Maps.uniqueIndex的兄弟方法，Multimaps.index(Iterable, Function)通常针对的场景是：有一组对象，它们有共同的特定属性，我们希望按照这个属性的值查询对象，但属性值不一定是独一无二的。 比方说，我们想把字符串按长度分组。 PeekingIterator有时候普通的Iterator 接口不够。Iterators 支持方法 Iterators.peekingIterator(Iterator), 其 包装了一个 Iterator 返回 PeekingIterator, 是一种Iterator 的子类能够让你 peek() 在下一次调用next()时返回的元素。 注意: Iterators 返回 PeekingIterator 。peekingIterator 不支持 在调用 peek()之后.remove() 。"},{"title":"Windows下安装nodejs","date":"2021-09-12T03:33:45.000Z","url":"/post/29038b71.html","tags":[["安装","/tags/%E5%AE%89%E8%A3%85/"],["nodejs","/tags/nodejs/"]],"categories":[["安装教程","/categories/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"]],"content":"node js 安装下载 官网下载页面 下载64位Windows Binary (.zip) 解压，并移动到安装位置 配置环境变量 NODE_HOME=C:\\SoftWare\\Nodejs\\node-v12.18.3-win-x64 path中增加%NODE_HOME% 测试是否配置成功 npm -v node -v 全局模块目录 及 缓存目录配置 npm 安装的 全局模块目录，以及 缓存目录。 为什么要配置这两个目录呢？ 在执行全局安装语句时，如： -g：可选参数 -g，g 代表 global，全局安装的意思 当前是基于解压版安装的，默认会将 express 模块安装至 &#123;解压目录&#125;\\node_modules 目录中，如我当前的是：F:\\Node.js\\dev_tools\\node\\v10.14.1\\node_modules；npm 的缓存文件会保存至 C:\\Users\\%USERNAME%\\AppData\\Roaming\\npm-cache 目录。如果是基于安装文件直接安装的，那么这两个文件夹都默认在 C 盘下，这样就会占用我们 C 盘的空间。 可以自定义指定这两个文件夹吗？ 接下来开始配置这两个目录，指定「全局模块的安装目录」、「缓存目录」： 此时我们再执行一次全局安装 express 模块，可以看到出现了我们指定的目录。 我们的自定义配置会保存在 C:\\Users\\%USERNAME%\\.npmrc 文件中。 配置 NPM 镜像源我们可以指定 npm 的镜像源达到网络加速的效果，默认的源为：，在国内访问速度较慢。 此时，我们就可以使用一些国内优秀的 npm 镜像源，如： CNPM： 淘宝 NPM 镜像： 临时使用 持久使用 通过 cnpm 使用 注意：此时的 cnpm 也会有默认的配置，同样需要进行「NPM 配置」模块那样进行 全局模块目录 及 缓存目录 的相关设置。自定义配置会保存在 C:\\Users\\%USERNAME%\\.cnpmrc 文件中。 "},{"title":"片源网站合集","date":"2021-09-12T03:33:07.000Z","url":"/post/af7391db.html","tags":[["片源","/tags/%E7%89%87%E6%BA%90/"]],"categories":[["合集","/categories/%E5%90%88%E9%9B%86/"]],"content":"资源丰富的视频网站AGE动漫 蜜柑计划 蓝光特效字幕 奈菲影视 团长资源 人人影视 独播库 no视频 91美剧 哔嘀影视 完美看看 梦幻诗篇解析 记录片 记录片2 CK电影 高清电台 片源网（有4k） 片库（有4k） 一耳影视 茶杯狐 软件下载：手机端电脑端 电脑端也可点击这里进入GitHub下载"},{"title":"IDEA安装配置","date":"2021-09-12T03:31:56.000Z","url":"/post/77c13e18.html","tags":[["IDEA","/tags/IDEA/"],["配置修改","/tags/%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9/"]],"categories":[["配置","/categories/%E9%85%8D%E7%BD%AE/"]],"content":"IDEA 基本设置修改启动参数及默认编码IDEA安装目录bin/idea64.exe.vmoptions 修改以下参数 这里的值可以根据需要进行设置 加入一行 项目编码 修改字体 鼠标滚轮修改字体大小 配置Java环境File-&gt;Project Structure 配置Maven环境 鼠标悬停提示 自动编译 智能导包 启动时不自动打开上次的项目 版本控制中的文件，修改后变色 关闭注释内容报错 未保存的文件标记*号 代码补全忽略大小写 关闭代码重复提示 文件标签多行显示 类注释 方法注释 "},{"title":"Windows技巧","date":"2021-09-12T03:30:56.000Z","url":"/post/761adea4.html","tags":[["Windows","/tags/Windows/"]],"categories":[["Windows","/categories/Windows/"]],"content":"Windows内置功能使用技巧录屏与截屏点击Win+G进入控制界面，可以录屏截图，控制音量，查看资源占用，每个窗口可以置顶显示 不过的录屏码率特别高，需要注意 窗口最小化最小化当前窗口 Win+方向键↓ 最小化所有窗口 Win+M，Win+shift+M恢复 最小化其他窗口 Win+home或拖动窗口摇晃，再次点击Win+home恢复 窗口排列将窗口拖动到左、左上、左下、右、右上、右下几个位置，界面会给出提示，松开鼠标自动排列 或者Win+方向键↑←↓→，自己摸索，很方便 批量重命名没啥卵用的功能，但是说不定能用到呢 选中需要重命名的文件或文件夹，右键其中一个重命名，其他文件会自动重命名并增加序号 选中后直接点击F2也是一样的效果 特殊字符自带的特殊字符还挺多的 win+R 输入charmap Windows放大镜 Win+加号 打开资源管理器不用再Win+D返回桌面，点击我的电脑了，Win+E直接打开资源管理器 截图直接使用键盘上的ps键不太好用，Win+ps又不能选择区域，新增加的截图方式Win+shift+S 可以自己选择截图形状和区域,截取后自动复制到剪贴板，在Windows通知中心可以选择保存图片 虚拟桌面当工作需要涉及到大量的文件，文件夹，应用时，可以启动虚拟桌面，相当于新建一个工作区域，两个桌面的文件和文件夹是独立显示的 浏览 Win+tab 快速创建虚拟桌面 Win+Ctrl+D 关闭当前桌面 Win+Ctrl+F4 便签Windows是有内置便签的，以后遇到需要记录的东西不需要新建txt文件或者使用OneNote了，因为这个自带的便签真的很好用 休眠模式睡眠模式和休眠模式的区别 睡眠模式：相当于省电模式，停掉所有进程的运行状态，保持内存的使用，此时CPU几乎不运行，消耗非常少量的电量保持内存数据不丢失，等唤醒时，只需要很少量的时间准备数据，CPU重新开始运行，进程恢复到睡眠之前的状态。 休眠模式：相当于关机，但是关机前将内存中所有的数据以及进行状态一起存储到硬盘中，此时是完全不耗电的，把电源拔掉也没事，下次开机时，从硬盘中读取数据写回内存，进程恢复到休眠之前的状态，比正常开机速度快 对了，顺便提一下，Windows关机再开机与重启效果是不一样的，关机再开机与休眠类似，也是会把部分数据从内存写到硬盘中，下次开机读回内存，而重启则是真正的重新启动。因此重启会比关机开机慢，所以电脑出问题需要重启的，一定要点重启，而不是先关机再开机 Win10默认是没有打开休眠模式的，需要手动开启 设置-系统-电源和睡眠-其他电源设置-选择电源按钮的功能-更改当前不可用的设置-勾选休眠，保存修改 然后电源选项里就会有休眠选项了 历史剪贴板Win10 1903 新增的功能，保留历史剪贴板数据，Win+V打开历史剪贴板，这功能盼星星盼月亮终于盼来了。 磁盘管理查看硬盘分区状态 选中分区后右键有个压缩卷的选项，点击后输入容量点击压缩可以对该分区进行拆分，拆分之后会出现新的空白卷，新建简单卷，分配盘符就有了新的分区了 自启动管理 文件共享特别是在局域网中，实现资源共享是很方便的，选中文件夹，右键属性，进入共享页签，点击共享，选中用户开启共享，下一步提示一般选择否，在公共网络下还是关闭共享比较好。接着就成功开启了这个文件夹的共享 同一网络下的计算机，在网络下会显示共享文件夹，点击输入用户名和密码就可以直接对里面的文件进行操作，以后想要共享的文件直接放到这个文件夹里面就可以了 要关闭共享的话，进入计算机管理，找到找到共享文件夹，右键停止共享就可以了 任务管理器任务管理器标题栏右键选择需要显示的列，一般常用的就是CPU，内存，磁盘和GPU，集显和独显卡都有话，这里的GPU会有GPU0和GPU1，GPU0是集显，GPU1是独显，玩游戏卡时可以看看独显是不是看不起这款游戏而偷懒了 清理系统文件Windows大版本更新之后，旧数据会特别大，最好是清理一下，强迫症平时也可以清理下，释放C盘空间 桌面图标显示默认在桌面是不显示我的电脑的 桌面空白处右键，个性化，主题，桌面图标设置，勾选计算机，选择应用，桌面就会出现我的电脑了，所有别再放个快捷方式到桌面上了，不好看 远程桌面连接远程连接Windows Win+R，输入mstsc回车，输入目标电脑IP回车，输入目标电脑用户名和民吗，就可以远程连接了。目标电脑会进入锁屏状态。 远程连接Linux Windows增加了SSH远程登录的功能 Win+R 输入cmd回车 输入 ssh root@192.168.100.102 回车，这里的root和192.168.100.102修改成你的远程主机用户名和IP，目前好像是不能改端口，只能默认22端口 第一次连接会提示是否连接，输入yes回车，接着提示输入密码，输入时不会显示出来，输入完直接回车就行。 待续。。。"},{"title":"CentOS7安装nginx","date":"2021-09-12T03:29:34.000Z","url":"/post/c73f62dc.html","tags":[["CentOS","/tags/CentOS/"],["安装","/tags/%E5%AE%89%E8%A3%85/"],["Nginx","/tags/Nginx/"]],"categories":[["安装教程","/categories/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"]],"content":"CentOS7安装nginx检查并安装所需的依赖软件 gcc nginx编译依赖gcc环境 pcre (Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用 pcre来解析正则表达式 zlib 该库提供了很多种压缩和解压缩的方式，nginx使用zlib对 http包的内容进行gzip openssl 一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http 协议，还支持https（即在ssl协议上传输 http） 安装nginx（以1.17.2为例） 创建nginx文件夹 进入文件夹 下载nginx源码包 解压 进入文件夹 配置编译参数 编译安装 可以进入/usr/local/nginx查看文件是否存在conf、sbin、html文件夹，若存在则安装成功 启动nginx 进入安装目录 启动 查看启动情况 如果有master和worker两个进程证明启动成功 nginx的关闭 快速关闭 完整停止(建议使用) 此方式停止步骤是待nginx进程处理任务完毕进行停止 设置开启启动 在系统服务目录里创建nginx.service文件 写入如下内容 配置说明如下 [Unit] Description: 描述服务 After: 描述服务类别 [Service] 服务运行参数的设置 Type=forking 是后台运行的形式 ExecStart为 服务的具体运行命令 ExecReload 重启命令 ExecStop 停止命令 PrivateTmp=True 表示给服务分配独立的临时空间 注意：[Service]的启动、重启、停止命令全部要求使用绝对路径 [Install] 运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3 nginx加入系统服务 设置开机自启动 查看nginx状态 很奇怪，明明启动成功了，为什么显示Active: inactive (dead) 杀死nginx重启nginx 查看状态 没有有master和worker两个进程表示nginx关闭成功 通过systemctl启动nginx 再次查看状态，变成了active 重启服务器，查看服务状态 "},{"title":"CentOS7 修改ssh端口，防暴力破解","date":"2021-09-12T03:28:14.000Z","url":"/post/a5230b7d.html","tags":[["CentOs","/tags/CentOs/"],["安全","/tags/%E5%AE%89%E5%85%A8/"]],"categories":[["安全","/categories/%E5%AE%89%E5%85%A8/"]],"content":"CentOS 7 修改默认ssh端口及防暴力破解措施修改默认ssh端口 修改sshd_config 找到如下内容 保存退出 防火墙白名单增加新端口 permanent是保存配置，不然下次重启以后这次修改无效 若提示firewall未启动，请先执行 设置防火墙自动启动 刷新防火墙 查看添加端口是否成功，如果添加成功则会显示yes，否则no 修改SELinux 查看当前SElinux 允许的ssh端口 可能出现 执行如下命令 然后 查看SELinux模式 显示如下信息 开启SELinux 若SELinux模式为Disabled，则需要开启SELinux 将SELINUX=disabled改为SELINUX=enforcing 重启服务器 检查SELinux模式 查看 SELinux 的政策 (Policy) 添加新ssh端口到 SELinux 确认是否添加成功 如果成功会输出 重启ssh 测试新端口的ssh连接 测试修改端口以后的ssh连接，如果成功则将sshd_config中的Port 22 重新注释掉 防止暴力破解ssh密码思路为读取/var/log/secure，查找关键字 Failedcat /var/log/secure | grep Failed从这些行中提取IP地址，如果次数达到10次(脚本中判断次数字符长度是否大于1)则将该IP写到 /etc/hosts.deny中 创建脚本 写入如下内容 加入定时计划 将secure_ssh.sh脚本放入cron计划任务，每十分钟执行一次。 增加一行 "},{"title":"CentOS7.3安装mysql","date":"2021-09-12T03:27:18.000Z","url":"/post/e2901e04.html","tags":[["CentOS","/tags/CentOS/"],["安装","/tags/%E5%AE%89%E8%A3%85/"]],"categories":[["安装教程","/categories/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"]],"content":"CentOS7.3安装mysql卸载CentOS7自带的mariadb 查看是否安装有mariadb 卸载mariadb 执行上一步操作后不为空，有mariadb，执行以下命令卸载 若提示有冲突 强制卸载 继续查看 若依然不为空，继续执行上一步操作，直至为空 安装mysql 下载mysql rpm包 将下载的rpm包上传到服务器任意目录 安装软件源 安装mysql服务端 启动mysql 检查mysql运行状态 获取mysql临时密码 Mysql5.7默认安装之后root是有密码的。 出现如下信息 这里默认密码为：syKqgjung1-M 登录mysql 输入刚才看到的密码 修改密码 如果密码设置太简单出现以下的提示 必须修改两个全局参数：首先，修改validate_password_policy参数的值 再修改密码的长度 再次执行修改密码就可以了 授权其他机器登录 一般是通过远程连接工具操作mysql的，所以需要授权其他机器登录mysql 最后可以删除rmp包先退出mysql 删除rpm包 "},{"title":"CentOS 7环境下安装java8（oracle）","date":"2021-09-12T03:26:08.000Z","url":"/post/2b92399d.html","tags":[["CentOS","/tags/CentOS/"],["安装","/tags/%E5%AE%89%E8%A3%85/"]],"categories":[["安装教程","/categories/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"]],"content":"CentOS 7环境下安装jdk（oracle）oracle官网下载对应的jdk服务端建议安装server jre，见文档末尾 创建jdk的安装目录 进入目录 解压这里以jdk-8u221-linux-x64.tar.gz为例 解压完成后目录下会出现文件夹jdk1.8.0_221 配置环境变量 在最后面增加 刷新环境变量 验证环境变量是否配置成功 出现如下内容则配置成功 删除jdk压缩包 服务器环境建议安装server jre安装方法与安装jdk相同，到oracle官网下载对于版本的server jre即可"},{"title":"Windows小工具","date":"2021-09-12T03:24:28.000Z","url":"/post/ef0ae4b.html","tags":[["Windows","/tags/Windows/"],["工具","/tags/%E5%B7%A5%E5%85%B7/"]],"categories":[["工具","/categories/%E5%B7%A5%E5%85%B7/"]],"content":"Windows小工具TrafficMonitor 流量监控工具 显示当前上传，下载速度 显示当前cpu和内存占用情况 在任务栏显示 详情和下载 PicPick 截图工具 占用资源少 快捷键自定义 截图后可编辑 详情和下载 Notepad++ 文本编辑工具 占用资源少，可完全替代Windows 记事本 多种语言的语法高亮 安装插件扩展功能 详情和下载 TeamViewer 远程控制工具 远程控制 被检测为商用后收费 太贵，买不起 详情和下载 向日葵 远程控制工具 个人版免费 个人版没有TeamViewrr流畅 详情和下载 HandShaker 手机电脑文件传输 电脑查看手机文件 电脑浏览手机相册 文件互传 粘贴板共享 锤子科技的产品 详情和下载 pandownload 百度网盘下载工具 提高下载速率 非会员用户可能被发现，然后限速kb/s 封号后随便开个会员即可解除限速 详情和下载 7zip 文件压缩工具 体积小，优化好 支持压缩格式多 免费，无广告 界面简陋 详情和下载 Typora Markdown编辑工具 占用资源少，简洁 实时预览 可更换主题 详情和下载 待续。。。"}]